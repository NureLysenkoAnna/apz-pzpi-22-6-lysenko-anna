МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ  УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


Кафедра «Програмної інженерії»


ЗВІТ
з лабораторної роботи №5
з дисципліни «Архітектура програмного забезпечення»
на тему: «Розгортання програмної системи та демонстрація її роботи»


Виконала                            Перевірив
ст. гр. ПЗПІ-22-6                   ст. викладач кафедри ПІ
Лисенко Анна Миколаївна             Сокорчук Ігор Петрович


Харків 2025

1 ІСТОРІЯ ЗМІН
№       Дата            Версія звіту        Опис змін та виправлень
1       12.06.2025          0.1             Створено розділи «Історія змін», «Завдання».
2       13.06.2025          0.2             Заповнено розділи «Опис виконаної роботи», «Висновки».
3       13.06.2025          0.3             У додаток Б додано побудовані діаграми.
4       13.06.2025          0.4             У додатку В представлено приклади коду.
5       13.06.2025          0.5             Додано у додаток А посилання на відео, описано його хронологію. 
     
2 ЗАВДАННЯ
1. Розгорнути створену програмну систему, що складається з серверної частини, IoT-клієнта, вебклієнта та мобільного (Android) клієнта.
2. Забезпечити коректну взаємодію кожної складової програної системи. 
3. Перевірити та продемонструвати роботу всієї системи, функцій адміністрування та взаємодії.
     
3 ОПИС ВИКОНАНОЇ РОБОТИ
1. Опис архітектури та взаємодії частин системи:
Програмна система для виявлення витоків газу реалізована як розподілена багаторівнева система, що складається з кількох окремих підсистем: серверної частини, IoT-застосунку (клієнта сенсорів), вебклієнта та мобільного клієнта. Кожен із компонентів використовує власний стек технологій і взаємодіє через стандартні протоколи, зокрема REST API та MQTT.
Серверна частина реалізована за допомогою технології ASP.NET Core, мовою програмування C#. Вона виконує роль центрального елемента всієї системи: обробляє запити від клієнтських застосунків, керує авторизацією та ролями користувачів, зберігає дані в базі та надсилає повідомлення у разі виявлення критичних ситуацій. Взаємодія з базою даних MS SQL Server реалізована через ORM-фреймворк Entity Framework Core. Дані про користувачів, сенсори, перевірки, події та показники зберігаються у вигляді реляційних таблиць з чітко визначеними зв’язками.
IoT-застосунок розроблено мовою програмування C#. Він імітує роботу фізичних сенсорів, які передають показники (рівень газу, температуру, тиск) у системі. На основі цих показників локально визначається рівень загрози (наприклад, підвищений рівень газу). Отримані дані публікуються через MQTT-протокол на брокер, звідки їх отримує сервер для подальшої обробки. Крім того, IoT-клієнт періодично виконує HTTP-запити до бекенд-сервісу для отримання списку активних сенсорів, їхнього стану та базових метаданих. Архітектурно IoT-застосунок виконує такі функції: симуляція даних, збір інформації про активні сенсори, оцінка ризику, передача подій і значень через MQTT. Таким чином, у його роботі задіяні два мережеві протоколи: MQTT (для передачі даних у реальному часі) та HTTP (для отримання допоміжної інформації з сервера).
Вебклієнт реалізовано з використанням JavaScript та React для побудови компонентного інтерфейсу. HTML і CSS застосовуються для структурування й стилізації, а Axios В для здійснення HTTP-запитів до серверної частини. Аутентифікація користувачів реалізована через JWT-токени, які зберігаються на клієнті та автоматично додаються до запитів. Система підтримує різні ролі: мешканець, менеджер, адміністратор системи, адміністратора бізнес-логіки, адміністратора бази даних, що мають доступ до персоналізованих функцій (перегляд сенсорів, бізнес-логіки, аналітики, управління користувачами, перевірками тощо). Завдяки React вебзастосунок забезпечує динамічне оновлення інтерфейсу, гнучкість у розширенні та зручну інтеграцію з серверною логікою.
Мобільний клієнт розроблено для платформи Android за допомогою мови Kotlin та Android Studio. Додаток призначений для мешканців будинку   користувачів з обмеженими правами, які можуть лише переглядати інформацію про сенсори, встановлені у їхній локації. Після авторизації (доступ дозволено лише ролі "Resident") користувач бачить список доступних сенсорів, може переглядати історію їхніх перевірок та останні показники. Отримання даних відбувається через REST API із застосуванням бібліотеки Retrofit. Для зберігання токена авторизації використовується SharedPreferences. Усі запити до сервера виконуються в асинхронному режимі за допомогою Kotlin Coroutines.
Усі частини системи взаємодіють між собою через стандартизовані API. Дані з сенсорів надходять до серверної частини, де обробляються та зберігаються в базі даних. Клієнтські застосунки (веб і мобільний) звертаються до серверу з метою отримання чи надсилання інформації. Такий підхід забезпечує масштабованість, безпеку й модульність системи.
2. Розгортання програмної системи для виявлення витоків газу
Для розгортання системи (локально) необхідно підготувати такі інструменти: .NET SDK (версія 8+), Microsoft SQL Server, Node.js з npm, Android Studio та MQTT-брокер Mosquitto. Середовище розробки може включати Visual Studio або VS Code.
Спочатку створюється база даних GasLeakDetectionDB, і за допомогою Entity Framework Core застосовуються міграції (dotnet ef database update). Після цього серверна частина запускається через dotnet run, надаючи доступ до REST API.
Вебклієнт, реалізований на React, розгортається окремо. Для цього виконується npm install, а далі npm start. У файлі конфігурації (axiosConfig.js) вказується адреса локального API.
Мобільний клієнт, створений на Kotlin в Android Studio, підключається до локального сервера за адресою 10.0.2.2 (при запуску через емулятор). Додаток дозволяє мешканцю переглядати сенсори, дані та перевірки.
IoT-клієнт, написаний на C#, генерує сенсорні дані, визначає рівень загрози, отримує список активних сенсорів по HTTP і публікує результати через MQTT. MQTT-брокер може бути локальним або в Docker-контейнері.
Кожен з модулів може бути запущений окремо, що дозволяє легко тестувати, налагоджувати або масштабувати систему.
     
4 ВИСНОВКИ
У результаті виконання лабораторної роботи було розгорнуто розроблену програмну систему для виявлення витоків газу та протестовано її функціональність. У додатку Б представлено ER-модель даних, структуру бази даних та UML-діаграму прецедентів.
     
ДОДАТОК А
Посилання на відеозапис та текст хронологічного опису відео
     
Відеозапис доповіді на YouTube: https://youtu.be/OeOL11ozehQ

Хронологічний опис відеозапису: 
00:00 ‒ Вступ.
00:11 ‒ Опис та демонстрація розробленого серверу.
00:44 ‒ Опис та демонстрація роботи розробленого IoT клієнта.
01:24 ‒ Взаємодія IoT з сервером.
01:41 ‒ Опис та демонстрація роботи розробленого вебклієнта.
02:26 ‒ Інтерфейс та користувацькі функції для ролі «Мешканець».
02:55 ‒ Інтерфейс та користувацькі функції для ролі «Менеджер».
04:11 ‒ Інтерфейс та користувацькі функції для ролі «Адміністратор бізнес-логіки».
06:53 ‒ Інтерфейс та користувацькі функції для ролі «Адміністратор бази даних».
07:10 ‒ Інтерфейс та користувацькі функції для ролі «Адміністратор системи».
08:52 ‒ Опис та демонстрація роботи розробленого мобільного клієнта.
10:09 ‒ Завершення показу.

ДОДАТОК Б
Графічні матеріали

Рисунок Б.1 ‒ ER-діаграма даних

Рисунок Б.2 ‒ Структура бази даних

Рисунок Б.3 ‒ UML-діаграма прецедентів

ДОДАТОК В
Програмний код

В.1 Математична обробка прикладних даних
GitHub репозиторій: https://github.com/NureLysenkoAnna/apz-pzpi-22-6-lysenko-anna/blob/main/Lab5/pzpi-22-6-lysenko-anna-lab5/server/BusinessLogic/SensorEventEvaluator.cs

1  public double CalculateDangerLevel(double gasLevel, double temperature, double pressure)
2  {
3      double maxGasLevel = 50000;
4      double maxTemperature = 30;
5      double maxPressure = 10;
6
7      return (gasLevel / maxGasLevel) + (temperature / maxTemperature)
8           + (pressure / maxPressure);
9  }
10
11  public bool IsDangerous(double dangerLevel, out string severity)
12  {
13      if (dangerLevel > 10)
14      {
15          severity = dangerLevel > 2 ? "High" : "Medium";
16          return true;
17      }
18
19      severity = "Low";
20      return false;
21  }

В.2 Адміністрування бізнес-логіки системи
GitHub репозиторій: https://github.com/NureLysenkoAnna/apz-pzpi-22-6-lysenko-anna/blob/main/Lab5/pzpi-22-6-lysenko-anna-lab5/server/BusinessLogic/SensorCheckAlert.cs
1  public async Task HandleSensorCheckResultAsync(SensorCheck sensorCheck)
2  {
3      if (sensorCheck.result.ToLower() != "failed") return;
4      var managerEmail = await _context.Users
5          .Where(u => u.role == "Manager")
6          .Select(u => u.email)
7          .FirstOrDefaultAsync();
8  
9      var sensor = await _context.Sensors
10                     .Include(s => s.Location)
11                     .FirstOrDefaultAsync(s => s.sensor_id == sensorCheck.sensor_id);
12  
13      if (sensor == null || sensor.Location == null) return;
14  
15      var locationName = sensor.Location.name ?? "невідомо";
16      var locationFloor = sensor.Location.floor.ToString() ?? "невідомо";
17
18      var subject = "Сенсор не пройшов технічну перевірку";
19      var body = $"Сенсор з ID {sensorCheck.sensor_id} не пройшов технічну перевірку та потребує оновлення.\n" +
20                 $"Розташування сенсора:\n" +
21                 $"- Локація: {locationName}\n" +
22                 $"- Поверх: {locationFloor}";
23  
24      await _emailService.SendEmailAsync(managerEmail, subject, body);
25  }

В.3 Резервне копіювання користувацьких даних
GitHub репозиторій: https://github.com/NureLysenkoAnna/apz-pzpi-22-6-lysenko-anna/blob/main/Lab5/pzpi-22-6-lysenko-anna-lab5/server/Backup/BackupService.cs

1  public class BackupService
2  {
3      private readonly string _sqlServer = @"localhost";
4      private readonly string _database = "GasLeakDB";
5      private readonly string _username = "UserName";
6      private readonly string _password = "Password";
7  
8      public string BackupDatabase()
9      {
10          var timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
11          var backupPath = $@"C:\DatabaseBackups\GasLeakDB_backup_{timestamp}.bak";
12  
13          var sql = $"BACKUP DATABASE [{_database}] TO DISK = N'{backupPath}' WITH NOFORMAT, INIT, " +
14                    $"NAME = N'{_database}-Full Database Backup', SKIP, NOREWIND, NOUNLOAD, STATS = 10;";
15  
16          var startInfo = new ProcessStartInfo
17          {
18              FileName = "sqlcmd",
19              Arguments = $"-S {_sqlServer} -U {_username} -P {_password} -Q \"{sql}\"",
20              RedirectStandardOutput = true,
21              RedirectStandardError = true,
22              UseShellExecute = false,
23              CreateNoWindow = true,
24          };
25  
26          using var process = new Process { StartInfo = startInfo };
27          process.Start();
28          var output = process.StandardOutput.ReadToEnd();
29          var error = process.StandardError.ReadToEnd();
30          process.WaitForExit();
31
32          if (process.ExitCode == 0)
33          {
34              return $"Backup successful. Saved to: {backupPath}";
35          }
36  
37          throw new Exception($"Backup failed. Error: {error}");
38      }
39  }